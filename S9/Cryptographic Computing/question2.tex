\section{Oblivious Transfer}
\localtableofcontents
\subsection{Definition and applications}%
\begin{itemize}
    \item The simplest version of Oblivious Transfer is the \textbf{1-out-of-2} OT or $2 \choose 1$-OT which has the following functionality
    \begin{itemize}
        \item Alice inputs a choice bit $b \in \{0,1\}$
        \item Bob inputs two messages $m_0, m_1$ 
        \item Alice learns $z = m_b$
    \end{itemize}
    \item \textbf{1-out-of-$n$ OT}: 
    \begin{itemize}
        \item Defined as the following functionality:
        \begin{enumerate}
            \item Alice inputs a choice value between $0$ and $n-1$
            \item Bob inputs $n$ messages 
            \item Alice only learns one of them 
            \item Bob does not learn which one
        \end{enumerate}
        \item This implies simple two-party secure computation protocols for passive adversaries and small functionalities which goes as follows:
        \begin{enumerate}
            \item Alice uses her input $x$ as the choice value
            \item Bob uses his input $y$ to construct the messages 
            \begin{equation*}
                M_0, \dots, M_{n-1} \text{ where } M_i = f(i,y)
            \end{equation*}
        \end{enumerate}
    \end{itemize}
    \item \textbf{Removing the Dealer from BeDOZa:} OT helps design secure two-party computation protocols which do not need a trusted dealer. The trusted dealer from BeDOZa can be implemented using a $4 \choose 1$-OT
    \begin{itemize}
        \item The dealer should sample random bits $u_\A, v_\A, u_\B, v_\B, w_\B$ and compute
        \begin{equation*}
            w_\A = (u_\A \oplus u_\B) \cdot (v_\A \oplus v_\B) \oplus w_\B
        \end{equation*}
        it sends $(u_\A, v_\A, w_\A)$ to $\A$ and $(u_\B, v_\B, w_\B)$ to $\B$
        \item The dealer can be replaced using the following simple protocol using a $4 \choose 1$-OT:
        \begin{enumerate}
            \item $\A$ samples random bits $u_\A, v_\A$ and inputs $i = 2 \cdot u_\A + v_\A$ to the OT
            \item $\B$ samples random bits $u_\B, v_\B, w_\B$ and inputs to the OT the following four messages:
            \begin{align*}
                M_0 &= (0 \oplus u_\B) \cdot (0 \oplus v_\B) \oplus w_\B \\
                M_1 &= (0 \oplus u_\B) \cdot (1 \oplus v_\B) \oplus w_\B \\
                M_2 &= (1 \oplus u_\B) \cdot (0 \oplus v_\B) \oplus w_\B \\
                M_3 &= (1 \oplus u_\B) \cdot (1 \oplus v_\B) \oplus w_\B \\
            \end{align*}
            \item Alices sets $w_\A = M_i$
        \end{enumerate}
    \end{itemize}
\end{itemize}

\subsection{OTs with Passive Security}
\subsubsection{Oblivious Key Generation}
\begin{itemize}
    \item A PKE with \textbf{oblivious key generation} can be used to make a passive secure OT protocol which adds support for an alternative way of generating public-keys
    \begin{itemize}
        \item The public keys generated like this look like regular public-keys
        \item It is not possible to learn the secret key corresponding to the public key generated like this
    \end{itemize}
    \item A PKE with \textbf{oblivious key generation} which is a reguslar IND-CPA secure PKE which is defined by four algorithms $(\Gen, \Enc, \Dec, \OGen)$ where $\OGen$ is used to generate random looking public keys and it is required that
    \begin{enumerate}
        \item Let $b$ be a random bit, $pk_0 \leftarrow \Gen(sk)$ and $pk_1 \leftarrow \OGen(r)$ be the oblivious public key generation algorithm then there is no PPT algorithm $D$ such that $D(pk_b) = b$ with probability significantly large than $1/2$
        \item It is possible to efficiently invert $pk \leftarrow \OGen(r)$ by using $r \leftarrow \OGen^{-1}(pk)$
    \end{enumerate}
    Properties 1 and 2 imply:
    \begin{enumerate}
        \item[3.] There exist no PPT (efficient) algorithm $A$ that can output $sk \leftarrow A(r)$ such that $\Gen(Sk) = \OGen(r)$
    \end{enumerate}
    This can be seen since we by property 2 it should be able to invert all public keys including the ones generated by $\Gen(sk)$ by property 1. Therefore we could use such an algorithm as follows to efficiently compute $sk$ from a generated public-key:
    \begin{equation*}
        sk \leftarrow A(\OGen^{-1}(pk))
    \end{equation*}
    which would be a contradiction with the underlying security of the PKE encryption scheme. 
    \\
    For the OT protocol to be secure a strong property is needed. This protocol states that the protocol is still CPA secure even if all the encryptions are performed using a public key which is output of $\OGen$
    \begin{enumerate}
        \item[4.] For all $m$: Let $b$ be a random bit, $m_0 = m$, $m_1$ be a uniform random message and $pk \leftarrow \OGen(r)$. Then there exist no PPT (efficent) algorithm $D$ such that $D(r, \Enc(pk, m_b)) = b$ with probability significantly larger than $1/2$
    \end{enumerate}
    This follows from the fact that this would imply that normal generated public keys would also be distinguishable since they are possible to invert to find $1$ by property $2$ which is a gives a contradiction with the fact that the underlying protocol is CPA secure. This must also hold for all keys generated by $\OGen$ since if this was not the case we would be able to distinguish between real and generated keys which would be a contradiction with property $1$.
\end{itemize}

\subsubsection{ElGamal Cryptosystem as OKG}
\begin{itemize}
    \item \textbf{ElGamal Cryptosystem} The ELGamal Cryptosystem allows for an oblivious key generation procedure
    \item Given a description of a group where the DDH assumption is believed to hold $(G, g, q)$ ElGamal is described by the four following algorithm
    \begin{itemize}
        \item $\Gen(sk)$: On input a secret key $sk = \alpha \in Z_q$ compute $h= g^\alpha$ and output $pk = (g,h)$
        \item $\Enc_{pk}(m)$: on input a message $m \in G$ sample a random $r \in Z_q$, parse $pk = (g, h)$ and output $C = (g^r, m \cdot h^r)$
        \item $\Dec_{sk}(C)$: parse $C$ as $(c_1, c_2)$ and output $m = c_2 \cdot c_1^{-\alpha}$
    \end{itemize}
    \item $\OGen(r)$: is done in a way that depends on the specific group e.g. for the multiplicative subgroup of order $q$ of $Z_p^*$ where $p$ is prime and $p = 2q + 1$
    \begin{itemize}
        \item Use the random string $r$ to sample a random number $s$ between $1$ and $p$ and output $h = s^2 \mod p$
        \item This is easily revertible since it is easy to compute square root modulo a prime
    \end{itemize}

\end{itemize}

\subsubsection{OT Protocols using OKG}
\begin{itemize}
    \item Given a PKE with Oblivious key generation $(\Gen, \Enc, \Dec, \OGen)$ we can generate the following OT protocol
    \begin{itemize}
        \item \textbf{Choose:} $\A$ with choice bit $b$
        \begin{enumerate}
            \item Samples random $sk$, $r$
            \item Generates $pk_b \leftarrow \Gen(sk), pk_{1-b} \leftarrow \OGen(r)$
            \item Sends $(pk_0, pk_1)$ to $\B$
        \end{enumerate}
        \item \textbf{Transfer Phase:} $\B$ with input messages $m_0, m_1$
        \begin{enumerate}
            \item Computes $c_0 = \Enc_{pk_0}(m_0; r_0)$ and $c_1 = \Enc_{pk_1}(m_1 ; r_1)$ using random $r_0,r_1$
            \item Sends $(c_0, c_1)$ to $\A$
        \end{enumerate}
        \item \textbf{Retrieve Phase:} $\A$ outputs $m_b \leftarrow \Dec(sk, c_b)$
    \end{itemize}
    this protocol is secure since we can create the following simulator $\mathcal S$ that can generate the view $\view_\A = \{sk, r, pk_b, pk_{b-1}, c_0, c_1\}$ of $\A$ with the same distribution using the input $b$ and the output $m_b$
    \begin{enumerate}
        \item Randomly select $sk,r$ and compute
        \begin{align*}
            pk_b &\leftarrow \Gen(sk) \\
            pk_{b-1} &\leftarrow \OGen(r)
        \end{align*}
    \item $c_b = \Enc_{pk_b}(m_b)$ an sample a random string $m'_{b-1}$ and compute
    \begin{equation*}
        c_{b-1} = \Enc_{pk_{b-1}}(m'_{b-1})
    \end{equation*}
    \end{enumerate}
    The simulator and the real distribution are indistinguishable since
    \begin{itemize}
        \item $sk,r,pk_b, pk_{b-1}, c_b$ is computed the same way as in the protocol
        \item The distribution of $E_{pk_{b-1}}(m_{b-1}')$ are indistinguishable from the distribution of $E_{pk_{b-1}}(m_{b-1})$ by property 4
    \end{itemize}
\end{itemize}

\subsection{The GMW compiler}%
\begin{itemize}
    \item The previous protocol based on OKG is not active secure since $\A$ can sample both public keys using $\Gen$ and learn both maessage
    \begin{itemize}
        \item Bob has no way of knowing that Alice cheated since the two distribution are indistinguishable
    \end{itemize}
    \item The first attempt at making the protocol active secure is using a ZK proof
    \begin{itemize}
        \item It is used to let $\A$ prove that at least one of the keys are generated using $\OGen$ 
        \item After sending $(pk_0, pk_1)$ to Bob, the parties use the ZK box where the statement is $x = (pk_0, pk_1)$ the witness is $w = r$ and the relation $R$ accepts if 
        \begin{equation*}
            (pk_0 = \OGen(r) \lor pk_1 = \OGen(r))
        \end{equation*}
        where $\B$ leans the output and if it succeeds $\B$ continues or aborts otherwise
        \item \textbf{Attack:} This can be broken by choosing the $r$ for use in the ZK protocol as $r = \OGen^{-1}(pk_b)$ for one of the public-keys and thus one can easily generate both public keys using $\Gen$
    \end{itemize}
    \item The second attempt of making the protocol active secure uses whats called Coin flip into the well 
    \begin{itemize}
        \item In coinflip into a well $\B$ chooses a random value that $\A$s random value must depend on
        \begin{enumerate}
            \item $\A$ chooses a random string $r_A$ and randomness $s$ for the commitment scheme. She computes $c = \Com(r_A, s)$ and sends $c$ to $\B$
            \item $\B$ chooses a random string $r_\B$ and sends it to $\A$
            \item Alice output $r = r_\A \oplus r_\B$ and $s$. Bob output $(c, r_B)$
        \end{enumerate}
    \end{itemize}
    $r$ is a uniform random string in the end of the protocol and $\A$ cannot change the value since the $\Com$ is binding
    \begin{itemize}
        \item Using coin flip into a well a compiled protocol can be defined as follows:
        \begin{enumerate}
            \item $\A$ and $\B$ run the coinflip into a well protocol
            \item $\A$ generates $pk_b = \Gen(sk)$ and $pk_{1-b} = \OGen(r)$ using the $r$ from the previous protocol
            \item $\A$ sends $(pk_0, pk_1)$ to $\B$
            \item $\A$ and $\B$ uses the ZK box for the following relation: the statement is $x = pk_0, pk_1, c, r_\B)$ the witness is $w = (r,s)$ and the relation outputs $1$ if:
            \begin{equation*}
                c= \Com(r \oplus r_b, s) \land (pk_0 = \OGen(r) \lor pk_1 = OGen(r))
            \end{equation*}
        \end{enumerate}
        \item \textbf{Attack:} This attemt is essentially enough for compiling the simple passive OT, but in general another step is needed:
        \begin{itemize}
            \item If we run two copies of the protocol one after the other we can choose two different bits for the first case and the second case which clearly should not be allowed
        \end{itemize}
    \end{itemize}
    \item \textbf{The final attempt:} $\A$ should commit to her input bit at the beginning of the protocol and prove that everything that she is doing is consistent with both her input and the randomness from the coin flip box
    \begin{enumerate}
        \item $\A$ with input bit $b$ chooses random $r_\A, s, t$ computes $c= \Com(r_A, s)$ and $d= \Com(b,t)$. $\A$ sends $(c,d)$ to $\B$
        \item $\A$ and $\B$ engage in a ZK proof where the statement is $x = (c,d)$, the witness is $w=(b, r_\A, s ,t)$ and $R(x,w) = 1$ only if
        \begin{equation*}
            c = \Com(r_\A, s) \land d = \Com(b,t)
        \end{equation*}
        \item $\B$ chooses a random $r_\B$ and sends it to $\A$
        \item $\A$ defines $r = r_\A \oplus r_\B$. $\A$ chooses a random $sk$ and computes $pk_b = \Gen(sk)$ and $pk_{1-b} = \OGen(r)$, $\A$ sends $(pk_0, pk_1)$ to $\B$
        \item $\A$ and $\B$ engage in a ZK proof where the statement  $x = (c,d, r_\B, pk_0, pk_1)$, the witness is $w = (b, r_\A, s, t)$ and $R(x,w) = 1$ only if:
        \begin{equation*}
            c = \Com(r_\A, s) \land d =\Com(b,t) \land pk_{1-b} = \OGen(r_\A \oplus r_\B)
        \end{equation*}
        \item $\B$ sends $(e_0, e_1)$ to $\A$ where $e_i = \Enc(pk_i, m_i)$
        \item $\A$ outputs $m_b = \Dec(sk, e_b)$
    \end{enumerate}
    \item To prove that the protocol is secure against an actively corrupt $\A$ a simulator is constructed. In the hybrid model the simulator simulates all calls to the ZK box i.e. every time $\A$ inputs something to the ZK box the simulator learns $w$
    \begin{enumerate}
        \item $S$ receives $(c,d)$ from $A$
        \item $S$ receives $w=(b,r_\A, s,t)$ from $A$ 
        \item $S$ sends random $r_\B$ to $A$
        \item $S$ receives $(pk_0, pk_1)$ from $A$
        \item $S$ receives $w' = (b', r_A', s', t')$ from $A$
        \item If $w' \neq w$ or $pk_{1-b} \neq \OGen(r_\A \oplus r_\B)$ abort. Otherwise the simulator inputs $b$ to the ideal functionality and learns $m_b$
        \item The simulator computes $e_b = \Enc(pk_b, m_b)$ and $e_{1-b} = \Enc(pk_{1-b}, 0)$ and outpus the view for $\A$
        \begin{equation*}
            (b,t,r,s,r_\B, e_0, e_1)
        \end{equation*}
    \end{enumerate}
    The view is indistinguishable from the view of a corrupted party in the real protocol, since the only two differences between the real protocol and the simulation is
    \begin{enumerate}
        \item The simulation aborts if $w' \neq w$. The real protocol continues as long as $\Com(b',t') = \Com(b,t)$ and $\Com(r_\A', s') = \Com(r_\A, s)$. But if this happens we can use $\A$ to break the binding property of $\Com$
        \item In the simulation $e_{1-b} = \Enc(pk_{1-b}, 0)$ while in the protocol $e_{1-b} = \Enc(pk_{1-b}, m_{1-b})$. If the distinguisher succeds then one can break the IND-CPA security of $\Enc$ in the following way
        \begin{enumerate}
            \item Receive $pk$ from the IND-CPA challenger
            \item Query the IPA-CPA challenger with message $m_{1-b}$ and $0$ and receive a challenge ciphertext $e^*$
            \item Construct a simulated view where $r_\B = r_\A \oplus \OGen^{-1}(pk)$ and $e_{1-b} = e^*$ and feed it to the distinguisher
            \begin{itemize}
                \item If the distinguisher thinks the view is from the real protocol guess $0$ in the IND-CPA game
                \item If the distinguisher thinks the view simulated, guess 1 in the IND-CPA game
            \end{itemize}
        \end{enumerate}
    \end{enumerate}
    \item The GMW compiler is a very useful theoretical tool, since it allows to take any passive secure protocol and turn it into an active one
    \begin{itemize}
        \item All the tools used can be based on one-way functions only, which are the minimal assumption for cryptography
        \item In most cases the CMW-compile leads to very inefficient protocols
        \item In some cases it is possible to use ZK proof that are efficient for special languages
    \end{itemize}
\end{itemize}

